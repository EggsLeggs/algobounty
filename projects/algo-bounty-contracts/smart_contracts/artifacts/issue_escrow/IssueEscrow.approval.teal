#pragma version 11
#pragma typetrack false

// algopy.arc4.ARC4Contract.approval_program() -> uint64:
main:
    intcblock 0 1 8 4
    bytecblock "total_bounty" "algo_asset" "maintainer" "is_resolved" "initialized" "issue_id" 0x151f7c75
    // smart_contracts/issue_escrow/contract.py:4
    // class IssueEscrow(ARC4Contract):
    txn NumAppArgs
    bz main___algopy_default_create@15
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    assert
    pushbytess 0xff837658 0x960b6e31 0x0556803b 0x561ac80f 0xa640c552 0x1d43eebc // method "create_bounty(string,uint64,address)string", method "fund_bounty(uint64)string", method "distribute_payout(address,uint64)string", method "mark_resolved()string", method "refund(uint64)string", method "get_bounty_info()(string,uint64,uint64,address,uint64,uint64)"
    txna ApplicationArgs 0
    match create_bounty fund_bounty distribute_payout mark_resolved refund get_bounty_info
    err

main___algopy_default_create@15:
    txn OnCompletion
    !
    txn ApplicationID
    !
    &&
    return // on error: OnCompletion must be NoOp && can only call when creating


// smart_contracts.issue_escrow.contract.IssueEscrow.create_bounty[routing]() -> void:
create_bounty:
    // smart_contracts/issue_escrow/contract.py:16
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    extract 2 0
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 3
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/issue_escrow/contract.py:24
    // assert self.initialized.value == UInt64(0), "Bounty already initialized"
    intc_0 // 0
    bytec 4 // "initialized"
    app_global_get_ex
    assert // check self.initialized exists
    !
    assert // Bounty already initialized
    // smart_contracts/issue_escrow/contract.py:25
    // assert Txn.sender == maintainer, "Only maintainer can create bounty"
    txn Sender
    dig 1
    ==
    assert // Only maintainer can create bounty
    // smart_contracts/issue_escrow/contract.py:27
    // self.issue_id.value = issue_id
    bytec 5 // "issue_id"
    dig 3
    app_global_put
    // smart_contracts/issue_escrow/contract.py:28
    // self.total_bounty.value = UInt64(0)
    bytec_0 // "total_bounty"
    intc_0 // 0
    app_global_put
    // smart_contracts/issue_escrow/contract.py:29
    // self.algo_asset.value = algo_asset
    bytec_1 // "algo_asset"
    uncover 2
    app_global_put
    // smart_contracts/issue_escrow/contract.py:30
    // self.maintainer.value = maintainer
    bytec_2 // "maintainer"
    swap
    app_global_put
    // smart_contracts/issue_escrow/contract.py:31
    // self.is_resolved.value = UInt64(0)
    bytec_3 // "is_resolved"
    intc_0 // 0
    app_global_put
    // smart_contracts/issue_escrow/contract.py:32
    // self.initialized.value = UInt64(1)
    bytec 4 // "initialized"
    intc_1 // 1
    app_global_put
    // smart_contracts/issue_escrow/contract.py:34
    // return String("Bounty created for issue: ") + issue_id
    pushbytes "Bounty created for issue: "
    swap
    concat
    // smart_contracts/issue_escrow/contract.py:16
    // @arc4.abimethod()
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec 6 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts.issue_escrow.contract.IssueEscrow.fund_bounty[routing]() -> void:
fund_bounty:
    // smart_contracts/issue_escrow/contract.py:36
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/issue_escrow/contract.py:39
    // assert self.initialized.value == UInt64(1), "Bounty not initialized"
    intc_0 // 0
    bytec 4 // "initialized"
    app_global_get_ex
    assert // check self.initialized exists
    intc_1 // 1
    ==
    assert // Bounty not initialized
    // smart_contracts/issue_escrow/contract.py:40
    // assert self.is_resolved.value == UInt64(0), "Bounty already resolved"
    intc_0 // 0
    bytec_3 // "is_resolved"
    app_global_get_ex
    assert // check self.is_resolved exists
    !
    assert // Bounty already resolved
    // smart_contracts/issue_escrow/contract.py:41
    // assert amount > UInt64(0), "Amount must be greater than 0"
    dup
    assert // Amount must be greater than 0
    // smart_contracts/issue_escrow/contract.py:43-49
    // # Transfer ALGO from sender to this contract
    // itxn.AssetTransfer(
    //     xfer_asset=self.algo_asset.value,
    //     asset_receiver=Global.current_application_address,
    //     asset_amount=amount,
    //     asset_sender=Txn.sender
    // ).submit()
    itxn_begin
    // smart_contracts/issue_escrow/contract.py:45
    // xfer_asset=self.algo_asset.value,
    intc_0 // 0
    bytec_1 // "algo_asset"
    app_global_get_ex
    assert // check self.algo_asset exists
    // smart_contracts/issue_escrow/contract.py:46
    // asset_receiver=Global.current_application_address,
    global CurrentApplicationAddress
    // smart_contracts/issue_escrow/contract.py:48
    // asset_sender=Txn.sender
    txn Sender
    itxn_field AssetSender
    dig 2
    itxn_field AssetAmount
    itxn_field AssetReceiver
    itxn_field XferAsset
    // smart_contracts/issue_escrow/contract.py:43-44
    // # Transfer ALGO from sender to this contract
    // itxn.AssetTransfer(
    intc_3 // axfer
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/issue_escrow/contract.py:43-49
    // # Transfer ALGO from sender to this contract
    // itxn.AssetTransfer(
    //     xfer_asset=self.algo_asset.value,
    //     asset_receiver=Global.current_application_address,
    //     asset_amount=amount,
    //     asset_sender=Txn.sender
    // ).submit()
    itxn_submit
    // smart_contracts/issue_escrow/contract.py:51
    // self.total_bounty.value = self.total_bounty.value + amount
    intc_0 // 0
    bytec_0 // "total_bounty"
    app_global_get_ex
    assert // check self.total_bounty exists
    +
    bytec_0 // "total_bounty"
    swap
    app_global_put
    // smart_contracts/issue_escrow/contract.py:36
    // @arc4.abimethod()
    pushbytes 0x151f7c75001a46756e64656420626f756e7479207375636365737366756c6c79
    log
    intc_1 // 1
    return


// smart_contracts.issue_escrow.contract.IssueEscrow.distribute_payout[routing]() -> void:
distribute_payout:
    // smart_contracts/issue_escrow/contract.py:54
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/issue_escrow/contract.py:61
    // assert Txn.sender == self.maintainer.value, "Only maintainer can distribute"
    txn Sender
    intc_0 // 0
    bytec_2 // "maintainer"
    app_global_get_ex
    assert // check self.maintainer exists
    ==
    assert // Only maintainer can distribute
    // smart_contracts/issue_escrow/contract.py:62
    // assert self.is_resolved.value == UInt64(1), "Issue not resolved yet"
    intc_0 // 0
    bytec_3 // "is_resolved"
    app_global_get_ex
    assert // check self.is_resolved exists
    intc_1 // 1
    ==
    assert // Issue not resolved yet
    // smart_contracts/issue_escrow/contract.py:63
    // assert amount <= self.total_bounty.value, "Insufficient bounty funds"
    intc_0 // 0
    bytec_0 // "total_bounty"
    app_global_get_ex
    assert // check self.total_bounty exists
    dup2
    <=
    assert // Insufficient bounty funds
    // smart_contracts/issue_escrow/contract.py:64
    // assert amount > UInt64(0), "Amount must be greater than 0"
    dig 1
    assert // Amount must be greater than 0
    // smart_contracts/issue_escrow/contract.py:66-72
    // # Transfer ALGO from contract to contributor
    // itxn.AssetTransfer(
    //     xfer_asset=self.algo_asset.value,
    //     asset_receiver=contributor,
    //     asset_amount=amount,
    //     asset_sender=Global.current_application_address
    // ).submit()
    itxn_begin
    // smart_contracts/issue_escrow/contract.py:68
    // xfer_asset=self.algo_asset.value,
    intc_0 // 0
    bytec_1 // "algo_asset"
    app_global_get_ex
    assert // check self.algo_asset exists
    // smart_contracts/issue_escrow/contract.py:71
    // asset_sender=Global.current_application_address
    global CurrentApplicationAddress
    itxn_field AssetSender
    dig 2
    itxn_field AssetAmount
    uncover 3
    itxn_field AssetReceiver
    itxn_field XferAsset
    // smart_contracts/issue_escrow/contract.py:66-67
    // # Transfer ALGO from contract to contributor
    // itxn.AssetTransfer(
    intc_3 // axfer
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/issue_escrow/contract.py:66-72
    // # Transfer ALGO from contract to contributor
    // itxn.AssetTransfer(
    //     xfer_asset=self.algo_asset.value,
    //     asset_receiver=contributor,
    //     asset_amount=amount,
    //     asset_sender=Global.current_application_address
    // ).submit()
    itxn_submit
    // smart_contracts/issue_escrow/contract.py:74
    // self.total_bounty.value = self.total_bounty.value - amount
    swap
    -
    bytec_0 // "total_bounty"
    swap
    app_global_put
    // smart_contracts/issue_escrow/contract.py:54
    // @arc4.abimethod()
    pushbytes 0x151f7c75001a446973747269627574656420746f20636f6e7472696275746f72
    log
    intc_1 // 1
    return


// smart_contracts.issue_escrow.contract.IssueEscrow.mark_resolved[routing]() -> void:
mark_resolved:
    // smart_contracts/issue_escrow/contract.py:80
    // assert Txn.sender == self.maintainer.value, "Only maintainer can mark resolved"
    txn Sender
    intc_0 // 0
    bytec_2 // "maintainer"
    app_global_get_ex
    assert // check self.maintainer exists
    ==
    assert // Only maintainer can mark resolved
    // smart_contracts/issue_escrow/contract.py:81
    // self.is_resolved.value = UInt64(1)
    bytec_3 // "is_resolved"
    intc_1 // 1
    app_global_put
    // smart_contracts/issue_escrow/contract.py:77
    // @arc4.abimethod()
    pushbytes 0x151f7c7500184973737565206d61726b6564206173207265736f6c766564
    log
    intc_1 // 1
    return


// smart_contracts.issue_escrow.contract.IssueEscrow.refund[routing]() -> void:
refund:
    // smart_contracts/issue_escrow/contract.py:84
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/issue_escrow/contract.py:87
    // assert Txn.sender == self.maintainer.value, "Only maintainer can refund"
    txn Sender
    intc_0 // 0
    bytec_2 // "maintainer"
    app_global_get_ex
    assert // check self.maintainer exists
    swap
    dig 1
    ==
    assert // Only maintainer can refund
    // smart_contracts/issue_escrow/contract.py:88
    // assert amount <= self.total_bounty.value, "Insufficient bounty funds"
    intc_0 // 0
    bytec_0 // "total_bounty"
    app_global_get_ex
    assert // check self.total_bounty exists
    dig 2
    dig 1
    <=
    assert // Insufficient bounty funds
    // smart_contracts/issue_escrow/contract.py:89
    // assert amount > UInt64(0), "Amount must be greater than 0"
    dig 2
    assert // Amount must be greater than 0
    // smart_contracts/issue_escrow/contract.py:91-97
    // # Transfer ALGO from contract back to maintainer
    // itxn.AssetTransfer(
    //     xfer_asset=self.algo_asset.value,
    //     asset_receiver=self.maintainer.value,
    //     asset_amount=amount,
    //     asset_sender=Global.current_application_address
    // ).submit()
    itxn_begin
    // smart_contracts/issue_escrow/contract.py:93
    // xfer_asset=self.algo_asset.value,
    intc_0 // 0
    bytec_1 // "algo_asset"
    app_global_get_ex
    assert // check self.algo_asset exists
    // smart_contracts/issue_escrow/contract.py:96
    // asset_sender=Global.current_application_address
    global CurrentApplicationAddress
    itxn_field AssetSender
    dig 3
    itxn_field AssetAmount
    uncover 2
    itxn_field AssetReceiver
    itxn_field XferAsset
    // smart_contracts/issue_escrow/contract.py:91-92
    // # Transfer ALGO from contract back to maintainer
    // itxn.AssetTransfer(
    intc_3 // axfer
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/issue_escrow/contract.py:91-97
    // # Transfer ALGO from contract back to maintainer
    // itxn.AssetTransfer(
    //     xfer_asset=self.algo_asset.value,
    //     asset_receiver=self.maintainer.value,
    //     asset_amount=amount,
    //     asset_sender=Global.current_application_address
    // ).submit()
    itxn_submit
    // smart_contracts/issue_escrow/contract.py:99
    // self.total_bounty.value = self.total_bounty.value - amount
    swap
    -
    bytec_0 // "total_bounty"
    swap
    app_global_put
    // smart_contracts/issue_escrow/contract.py:84
    // @arc4.abimethod()
    pushbytes 0x151f7c750016526566756e64656420746f206d61696e7461696e6572
    log
    intc_1 // 1
    return


// smart_contracts.issue_escrow.contract.IssueEscrow.get_bounty_info[routing]() -> void:
get_bounty_info:
    // smart_contracts/issue_escrow/contract.py:106
    // self.issue_id.value,
    intc_0 // 0
    bytec 5 // "issue_id"
    app_global_get_ex
    assert // check self.issue_id exists
    // smart_contracts/issue_escrow/contract.py:107
    // self.total_bounty.value,
    intc_0 // 0
    bytec_0 // "total_bounty"
    app_global_get_ex
    assert // check self.total_bounty exists
    // smart_contracts/issue_escrow/contract.py:108
    // self.algo_asset.value,
    intc_0 // 0
    bytec_1 // "algo_asset"
    app_global_get_ex
    assert // check self.algo_asset exists
    // smart_contracts/issue_escrow/contract.py:109
    // self.maintainer.value,
    intc_0 // 0
    bytec_2 // "maintainer"
    app_global_get_ex
    assert // check self.maintainer exists
    // smart_contracts/issue_escrow/contract.py:110
    // self.is_resolved.value,
    intc_0 // 0
    bytec_3 // "is_resolved"
    app_global_get_ex
    assert // check self.is_resolved exists
    // smart_contracts/issue_escrow/contract.py:111
    // self.initialized.value
    intc_0 // 0
    bytec 4 // "initialized"
    app_global_get_ex
    assert // check self.initialized exists
    // smart_contracts/issue_escrow/contract.py:102
    // @arc4.abimethod()
    dig 5
    len
    itob
    extract 6 2
    uncover 6
    concat
    uncover 5
    itob
    pushbytes 0x0042
    swap
    concat
    uncover 5
    itob
    concat
    uncover 4
    concat
    uncover 3
    itob
    concat
    uncover 2
    itob
    concat
    swap
    concat
    bytec 6 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return
